## [П]|[РС]|(РП) Проекции

После выполнения калибровки камеры (глава 11), появляется возможность однозначно спроецировать точки материального мира на изображение. Это означает, что засчёт координат положения точек материального мира, связанные с камерой, можно вычислить, где должна появиться на фотоприёмнике, в пикселях, внешняя трехмерная точка. В OpenCV данное преобразование может выполнить функция *cvProjectPoints2()*:

```cpp
void cvProjectPoints2(
     const CvMat*   object_points
    ,const CvMat*   rotation_vector
    ,const CvMat*   translation_vector
    ,const CvMat*   intrinsic_matrix
    ,const CvMat*   distortion_coeffs
    ,CvMat*         image_points
    ,CvMat*         dpdrot      = NULL
    ,CvMat*         dpdt        = NULL
    ,CvMat*         dpdf        = NULL
    ,CvMat*         dpdc        = NULL
    ,CvMat*         dpddist     = NULL
    ,double         aspectRatio = 0
);
```

На первый взгляд количество аргументов может быть немного пугающим, но на самом деле данная функция проста в использовании. Функция была разработана, чтобы приспособиться (очень обобщенно) к обстоятельствам, при которых проекционные точки должны расположиться на некотором твердом теле. В этом случае, естественно представить точки не просто как список положений в системе координат камеры, но и как список положения объекта в центре системы координат собственного тела; тогда можно добавить вращение и перемещение, указав отношение между координатами объекта и системой координат камеры. На самом деле, *cvProjectPoints2()* используется внутри *cvCalibrateCamera2()*. Все дополнительные аргументы предназначены, прежде всего, для *cvCalibrateCamera2()*, но опытные пользователи могут приспособить их и под свои нужды.

Первый аргумент *object_points* это список проецируемых точек, представляющий из себя матрицу Nx3 и содержащий положения точки. Положения этих точек могут быть предоставлены в системе координат объекта, с последующей передачей матриц 3x1 *rotation_vector* (как правило, представление Rodrigues) и *translation_vector*, связывающие две координаты. Если в конкретном случае удобнее работать непосредственно в системе координат камеры, то можно просто передать *object_points* в этой системе координат, а для *rotation_vector* и *translation_vector* установить все значения в 0 (при этом стоит помнить, что вектор вращения является представлением поворота вида ось-угол, поэтому установка всех значений в 0 означает, что вектор имеет нулевую величину, соответственно "вращения нет").

*intrinsic_matrix* и *distortion_coeffs* - это матрица внутренних параметров и коэффициенты искажения соответственно, которые приходят от *cvCalibrateCamera2()* (глава 11). Аргумент *image_points* это матрица Nx2, в которую будет записан вычисленный результат.

И наконец, длинный список дополнительных аргументов *dpdrot*, *dpdt*, *dpdf*, *dpdc* и *dpddist* - это все частные производные матрицы Jacobian. Эти матрицы связывают точки изображения с каждым из различных входных параметров. В частности: *dpdrot* это матрица Nx3 частных производных точек изображения по отношению к вектору вращения; *dpdt* это матрица Nx3 частных производных точек изображения по отношению к вектору перемещения; *dpdf* это матрица Nx2 частных производных точек изображения по отношению к ![Формула 12-1 не найдена](Images/Frml_12_1.jpg)  и ![Формула 12-2 не найдена](Images/Frml_12_2.jpg); *dpdc* это матрица Nx2 частных производных точек изображения по отношению к ![Формула 12-3 не найдена](Images/Frml_12_3.jpg) и ![Формула 12-4 не найдена](Images/Frml_12_4.jpg); *dpddist* это матрица Nx4 частных производных точек изображения по отношению к коэффициентам искажения. В большинстве случаев они не используются (значение NULL). Последний параметр *aspectRatio* также необязателен; он используется для производных только тогда, когда соотношение сторон фиксировано в *cvCalibrateCamera2()* или *cvStereoCalibrate()*. Если этот параметр не 0, то производные *dpdf* будут скорректированы.

