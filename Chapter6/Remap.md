## [П]|[РС]|(РП) Remap

"Под капотом", многие преобразования имеют некий общий элемент. В частности, они выбирают пиксели, находящиеся в одном положении и отображают их в другое положение. В этом случае, всегда будет некоторое гладкое отображение, которое будет выполнять запрашиваемое действие, при этом, не всегда выполняющийся перенос пикселей будет один к одному. 

Иногда, возникает необходимость программно произвести такую интерполяцию; т.е. применить какой-нибудь известный алгоритм, который будет определять отображение. Однако, в других случаях, нужно провести отображение по-своему. Прежде, чем перейти к более углубленному изучению методов осуществления такого отображения, рассмотрим функцию, отвечающую за применение отображений и составляющая основу для остальных методов. В OpenCV эта функция именуется как *cvRemap()*:

```cpp
void cvRemap(
     const CvArr*   src
    ,CvArr*         dst
    ,const CvArr*   mapx
    ,const CvArr*   mapy
    ,int            flags   = CV_INTER_LINEAR | CV_WARP_FILL_OUTLIERS
    ,CvScalar       fillval = cvScalarAll(0)
);
```

Первые два параметра *cvRemap()* - это исходное и конечное изображения. Очевидно, что они должны быть одинакового размера и с равным количеством каналов, но при этом иметь произвольный формат данных. Стоит отметить, что исходное и конечное изображения это два разных изображения (Немного поразмыслив, можно разобраться, почему наиболее эффективная стратегия отображения не совместима с записью в исходное изображение. В конце концов, если переместить пиксель A в положение B, а затем, когда дойдет очередь до перемещения B в положение C, окажется, что исходное значение B переписано значением A). Следующие два параметра, *mapx* и *mapy*, указывают положение в которое должны быть перемещены пиксели. Они должны быть такого же размера, как исходное и конечное изображения, но при этом одноканальными и, как правило, вещественного типа (*IPL_DEPTH_32F*). Нецелочисленные отображения являются допустимыми и *cvRemap()* производит необходимые интерполяционные вычисления автоматически. Одно из наиболее общих применений *cvRemap()* - подправить (устранить искажения) калибровку и стереоизображение. Эти варианты применения функции будут рассмотрены в главах 11 и 12. Следующие два параметра содержат флаги, точно указывающие *cvRemap()* каким образом производить интерполяцию. Все возможные значения указаны в таблице 6-1.

Таблица 6-1. Дополнительные значения флагов *cvWarpAffine()*

| Флаг | Значение |
| -- | -- |
| CV_INTER_NN | Ближайшие соседи |
| CV_INTER_LINEAR | Билинейная (по умолчанию) |
| CV_INTER_AREA | Перебор области пикселя |
| CV_INTER_CUBIC | Бикубическая интерполяция |

Интерполяция - это крайне важный момент. Пиксели в исходном изображении находятся на целочисленной сетке; так, например, можно обратиться к пикселю с координатами (20, 17). При отображении целочисленных координат в новое изображение, могут появиться зазоры - либо, поскольку целочисленные координаты пикселей на исходном изображении отображаются в вещественные координаты на конечном изображении и должны быть округлены до ближайшей целой координаты пикселя, либо из-за существования нескольких локаций, в которые пиксель не отображается (например, при увеличении изображения, путем растягивания; тогда каждый второй пиксель будет пустым). Эти проблемы обычно обобщаются как проблемы *прямого проецирования*. Чтобы разобраться с подобного рода проблемами округления и проблемами в конечном изображении, как правило, необходимо решить обратную задачу: совершить проход по каждому пикселю в конечном изображении и ответить на вопрос: "Какие пиксели исходного изображения необходимо перенести в пиксели конечного изображения?". Эти исходные пиксели почти всегда будут расположены в дробных координатах, так что потребуется интерполировать исходные пиксели, чтобы получить корректную величину для конечного пикселя. По умолчанию, применяется линейная интерполяция (таблица 6-1).

Флаги можно комбинировать (с использованием оператора OR); так добавление флага *CV_WARP_FILL_OUTLIERS* позволит заполнить те пиксели в конечном изображении, для которых нет пикселей в исходном, в соответствии со значением, указанном в последнем параметре *fillval*. В этом случае, при переносе изображения на круг, размещенного в центре, область вне круга будет автоматически заполнена черным цветом (либо любым указанным цветом).

