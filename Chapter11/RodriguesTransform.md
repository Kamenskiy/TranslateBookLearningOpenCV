## [П]|[РС]|(РП) Преобразования Rodrigues

При работе с трехмерным пространством, наиболее часто встречается задача представления матрицы вращения 3x3 в этом пространстве. Это представление, как правило, наиболее удобно, т.к. перемножение вектора и данной матрицы эквивалентно повороту вектора. Недостатком является то, что может быть затруднительно интуитивно понять, как вращать матрицу 3x3. В альтернативе несколько проще визуализировать (в данном контексте "проще" не только человеку; вращение в трехмерном пространстве представляется только тремя компонентами, поэтому более эффективно обрабатывать три компоненты представления Rodrigues, чем девять компонент матрицы вращения 3x3) представление для вращения в виде вектора, для которого вся работа сводится к оперированию одним углом. В этом случае стандартная практика использовать только один вектор для управления кодированием направления оси, вокруг которой будут производиться вращения, и его размер для кодирования количества вращений против часовой стрелки. Это легко выполнимо, т.к. направление может быть одинаково хорошо представлено вектором любого масштаба; следовательно, можно выбрать величину вектора равную величине поворота. Связи между этими двумя представлениями, матрицей и вектором, охвачены преобразованием Rodrigues. Пусть r это трехмерный вектор ![Формула 11-106 не найдена](Images/Frml_11_106.jpg); этот вектор неявно определяет θ, величину поворота длины (или величины) r. В результате можно преобразовать представление оси величин в матрицу вращения R следующим образом:

![Формула 11-107 не найдена](Images/Frml_11_107.jpg)

Так же возможно произвести обратную операцию (перейти от матрицы вращения к представлению оси величин) следующим образом:

![Формула 11-108 не найдена](Images/Frml_11_108.jpg)

Таким образом, все сводится к ситуации, в которой имеется одно представление (представление матрицы), которое наиболее удобно использовать для расчетов, и ещё одно представление (представление Rodrigues), которое немного проще для восприятия мозгом. OpenCV предоставляет функцию для преобразования из любого представления в любое другое представление.

```cpp
void cvRodrigues2(
     const CvMat*   src
    ,CvMat*         dst
    ,CvMat*         jacobian = NULL
);
```

Например, имеется вектор r и соответствующее необходимое представление матрицы вращения *R*; *src* будет соответствовать вектору r размера 3x1, а *dst* матрице вращения *R*. При этом значения *src* и *dst* можно поменять местами. В любом случае, *cvRodrigues2()* предоставит верный результат. Последний аргумент необязателен. Если *jacobian != NULL*, то это должен быть указатель на матрицу размера 3x9 или 9x3, которая будет заполнена частными производными компонентов конечного массива по отношению к компонентам исходного массива. Выходной аргумент *jacobian* в основном используется для внутренних алгоритмов оптимизации в *cvFindExtrinsicCameraParameters2()* и *cvCalibrateCamera2()*; в основном использование данного параметра ограничивается преобразованием выходов *cvFindExtrinsicCameraParameters2()* и *cvCalibrateCamera2()* из векторов Rodrigues ось-угол размера 1x3 или 3x1 в матрицы вращения. Для этого, необходимо просто оставить *jacobian = NULL*.

