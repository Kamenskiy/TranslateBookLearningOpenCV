## [П]|[РС]|(РП) Упражнения

Примеры реализации многих обсуждаемых в данной главе алгоритмов можно найти в *.../opencv/samples/c/*:

* *lkdemo.c* (оптический поток)
* *camshiftdemo.c* (mean-shift отслеживание цветных регионов)
* *motempl.c* (шаблоны движения)
* *kalman.c* (фильтр Kalman)


1. Используйте матрицу ковариации *Hessian* в функции *cvGoodFeaturesToTrack()* для выполнения вычислений по некоторой квадратной области, заданной при помощи *block_size*, изображения.

	a. Что будет происходить при увеличении размера блока? Будем получать больше или меньше "хороших особенностей"? Почему?

	b. Покопайтесь в коде *lkdemo.c*, найдите *cvGoodFeaturesToTrack()* и поиграйтесь с *block_size*, чтобы увидеть разницу.

2. Обратитесь к рисунку 10-2 и функции, которая реализует поиск угла субпикселя *cvFindCornerSubPix()*.

	a. Что произойдет, если (рисунок 10-2) шахматная доска будет сплетена таким образом, что прямые черные-белые линии сформируют кривые, которые пересекаются в точке? Будет ли работать поиск угла субпикселя? Ответ поясните.

	b. Если расширить размеры окна вокруг плетенной шахматной доски, то угол будет точкой (после расширения параметров *win* и *zero_size*), а вот после выполнения поиска угла субпикселя, угол станет более или менее точным? Ответ поясните.

3. Оптический поток

	a. Опишите объект, который будет лучше отслеживаться при помощи метода блочного сопоставление, а не метода *Lucas-Kanade*.

	b. Опишите объект, который будет лучше отслеживаться при помощи метода *Lucas-Kanade*, а не метода блочного сопоставления.

4. Скомпилируйте *lkdemo.c*. Подключите к программе камеру (или используйте ранее захваченную последовательность текстурированного движущегося объекта). Запустив программу, обратите внимание на то, что "r" автоматически инициализирует слежение, "c" очищает слежение, а клики мыши добавляют/удаляют новую/старую точку. Запустите *lkdemo.c* и инициализируйте отслеживание точки, нажав "r". Понаблюдайте за последствиями произведенных действий.

	a. Теперь откройте код и закомментируйте вызов функции *cvFindCornerSubPix()*. Навредит ли это результату? Каким образом?

	b. Еще раз откройте код и передайте в функцию *cvGoodFeaturesToTrack()* сетку точек вокруг объекта при помощи ROI. Опишите что происходит с точками и почему.
	
	Подсказка: часть происходящего является следствием проблем с диафрагмой - при фиксированном размере окна и линии, нельзя сказать, как перемещается линия.

5. Измените *lkdemo.c*, создав программу, которая выполняла бы простую стабилизацию изображения умеренно движущихся камер. Отобразите результаты стабилизации в центре наибольшего окна одной из камеры (так, чтобы кадр мог "зависнуть", пока первые точки остаются стабильными).

6. Скомпилируйте и запустите *camshiftdemo.c*, используя веб-камеру или цветное видео с передвигающимся цветным объектом. Используйте мышь, чтобы нарисовать прямоугольник вокруг движущегося объекта; соответствующая функция начнет отслеживать выбранный объект.

	a. В *camshiftdemo.c* замените *cvCamShif()* на *cvMeanShift()*. Опишите ситуации при которых один трекер работает лучше другого.

	b. Напишите функцию, которая бы передавала сетку точек в *cvMeanShift()*. Запустите оба трекера одновременно.

	c. Как нужно использовать эти два трекера одновременно, чтобы отслеживание было более надежным? Ответ поясните и/или проведите эксперимент.

7. Скомпилируйте и запустите шаблон движения из кода *motempl.c* с использованием веб камеры или заранее сохраненного видеофайла.

	a. Модифицируйте *motempl.c* так, чтобы можно было выполнить простое распознавание жестов.

	b. При условии, что камера движется, объясните, как задействовать код из упражнения 5 для стабилизации этих движений, дав шаблону движения возможность для работы.

8. Объясните, как можно отслеживать круговые (не линейные) движения за счет использования линейного состояния модели (не расширенного) фильтра Kalman.

9. Используйте модель движения с утверждением, что текущее состояние зависит от положения и скорости предыдущего состояния. Объедините *lkdemo.c* (используя только несколько кликов-точек) с фильтром Kalman для отслеживания лучших точек *Lucas-Kanade*. Покажите неопределенность вокруг каждой точки. В каком месте отслеживание будет провальным?

10. Фильтр Kalman зависит от линейной динамики и от Марковской независимости (т.е. предполагается, что текущее состояние зависит только от недавнего прошлого состояния, а не от всех предыдущих состояний). Допустим имеется объект для отслеживания, движения которого связаны с его предыдущим положением и скоростью, при этом ошибочно добавляется элемент динамики только для состояния, зависимого от предыдущего положения - другими словами, предыдущий элемент скорости забывается.

	a. Сохраняются ли предположения Kalman? Если да, то почему; если нет, то какие предположения нарушаются.

	b. При каких условиях фильтр Kalman может продолжить свою работу, если были позабыты некоторое элементы динамики?

11. Используйте веб-камеру или видео, где человек размахивает двумя яркими цветными объектами, по одному в каждой руке. Используйте *condensation* для отслеживания обеих рук.

