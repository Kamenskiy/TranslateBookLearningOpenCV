## [П]|[РС]|(РП) Хранилище памяти

OpenCV использует объект именуемый **memory storage** (хранилище памяти) в качестве метода управления выделением памяти для динамического объекта. *Memory storage* - это связанные списки блоков памяти, которые допускают быстрое распределение и перераспределение непрерывного набора блоков. Функции OpenCV, требующие выделение памяти для их нормального функционирования запрашивают доступ к *memory storage*, благодаря которому можно получить необходимую память (как правило, это функции, результаты которых имеют переменный размер)

Для работы с *memory storage* в OpenCV имеются следующие четыре функции:

```cpp
    CvMemStorage* cvCreateMemStorage(
         int block_size = 0
    );
    
    void cvReleaseMemStorage(
         CvMemStorage** storage
    );
    
    void cvClearMemStorage(
         CvMemStorage* storage
    );
    
    void* cvMemStorageAlloc(
         CvMemStorage*  storage
        ,size_t         size
    );
```

Для создания *memory storage* используется функция *cvCreateMemStorage()*. В качестве исходного значения функции передается размер блока, который устанавливает размер блока памяти в хранилище. Если этот аргумент установлен в 0, тогда по умолчанию будет использован блок размера 64kB. Функция возвращает указатель нового хранилища памяти.

Функция *cvReleaseMemStorage()* использует указатель хранилища памяти для освобождения занимаемой памяти. Это, по сути, соответствует освобождению изображений, матриц и других структур.

Для освобождения памяти так же можно воспользоваться *cvClearMemStorage()*, которая тоже принимает указатель на существующее хранилище. Однако необходимо знать одну особенность этой функции: это единственный способ освободить (для повторного использования этого хранилища) память, выделенную под хранилище. Это может показаться не столь важным, но есть процедуры, которые удаляют объекты внутри хранилища, а занимаемую память не освобождают. Короче говоря, только *cvClearMemStorage()* (и, конечно, *cvReleaseMemStorage()*) могут освобождать занимаемую память. (На самом деле функция *cvRestoreMemStoragePos()* может восстановить память в хранилище. Однако эта функция, прежде всего для внутреннего пользования библиотеки и выходит за рамки данной книги). Удаление любой динамической структуры (*CvSeq*, *CvSet* и т.д.) никогда не возвращает память обратно в хранилище (хотя структуры в состоянии снова использовать память, однажды взятую из хранилища под собственные данные).

Так же возможно выделение собственных блоков из хранилища при помощи функции *cvMemStorageAlloc()* по аналогии с тем, как *malloc()* выделяет память из кучи. В этом случае необходимо будет указать лишь указатель на хранилище и число требуемых байтов. Функция возвратит указатель типа *void*\* (подобно *malloc()*).

