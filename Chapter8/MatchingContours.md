## [П]|[РС]|(РП) Сопоставление контуров

Теперь, имея довольно таки хорошее представление о том, что такое контур и как с ними работать, можно перейти к рассмотрению применения этих знаний на практике. Наиболее распространённой задачей является *сопоставление контуров* тем или иным способом. Может возникнуть потребность сравнивать два вычисленных контура между собой или сравнить вычисленный контур с каким-то абстрактным шаблон. Собственно далее речь пойдет именно об этих двух случаях.


### Моменты

Наиболее простым способом сравнения двух контуров является вычисление *моментов контура*. Грубо говоря, момент – это грубая характеристика контура, вычисляемая путем интегрирования (или суммирования) по всем пикселям контура. В общем, момент контура (p, q) определяется следующим образом:

![Формула 8-8 не найдена](Images/Frml_8_8.jpg)

где *p* порядок *x*, *q* порядок *y*, а термин *порядок* означает степень, в которую возводится компонента суммы. Суммирование ведется по всем пикселям границы контура (обозначено в уравнение как *n*). Если *p* и *q* равны 0, то момент ![Формула 8-9 не найдена](Images/Frml_8_9.jpg) равен длине пикселей контура. (Математики-пуристы могут возразить, что ![Формула 8-9 не найдена](Images/Frml_8_9.jpg) на самом деле не длина, а площадь контура. Но так как в рассмотрение берется только контур, а не весь многоугольник, длина и площадь, на самом деле, одно и то же в дискретном пространстве пикселей (по крайней мере, для соответствующего дистанционного критерия в данном пространстве пикселей). Так же существует функция для вычисления моментов *IplImage* изображения; в этом случае, ![Формула 8-9 не найдена](Images/Frml_8_9.jpg) будет фактически равен площади ненулевых пикселей).

Следующая функция вычисляет моменты контура:

```cpp
void cvContoursMoments(
     CvSeq*     contour
    ,CvMoments* moments
)
```

Первый аргумент это контур, а второй это указатель на структуру, которую необходимо создать для хранения возвращаемых данных. Структура *CvMoments* выглядит следующим образом:

```cpp
typedef struct CvMoments {
    // пространственные моменты
    double m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;

    // центральные моменты
    double mu20, mu11, mu02, mu30, mu21, mu12, mu03;

    // m00 != 0 ? 1/sqrt(m00) : 0
    double inv_sqrt_m00;
} CvMoments;
```

Функция *cvContoursMoments()* использует только элементы *m00, m01, . . ., m03*; элементы с именами * mu00, ...* используются при работе с другой функцией.

При работе со структурой *CvMoment* можно использовать вспомогательную функцию, которая будет возвращать конкретный момент из структуры:

```cpp
double cvGetSpatialMoment(
     CvMoments* moments
    ,int        x_order
    ,int        y_order
);
```

При первом вызове функция *cvContoursMoments()* вычисляет все моменты до третьего порядка (т.е. ![Формула 8-10 не найдена](Images/Frml_8_10.jpg) и ![Формула 8-11 не найдена](Images/Frml_8_11.jpg) будут вычислены после ![Формула 8-12 не найдена](Images/Frml_8_12.jpg) и ![Формула 8-13 не найдена](Images/Frml_8_13.jpg), но перед ![Формула 8-14 не найдена](Images/Frml_8_14.jpg)).


### Подробнее о моментах

Только что описанное вычисление моментов дает некоторые элементарные характеристики контура, которые могут быть использованы для сравнения двух контуров. Тем не менее, моменты, получаемые из этих вычислений, в большинстве практических приложений не являются наилучшим способом для сравнения контуров. В частности, наиболее популярным подходом является использование *нормированных моментов* (так, объекты одинаковой формы, но разных размеров дают схожие значения). 

OpenCV предоставляет функции для вычисления нормированных моментов, а также *Hu инвариантного момента*. Структура *CvMoments* может быть вычислена при помощи *cvMoments()* или *cvContourMoments()*. Более того, для данного случая *cvContourMoments()* является псевдонимом для *cvMoments()*.

Стоит отметить один трюк, связанный с использованием *cvDrawContours()*: вызов одной из функций для работы с моментами на результате применения функции рисования контура позволяет контролировать заполнение контура.

```cpp
void cvMoments(
     const CvArr*   image
    ,CvMoments*     moments
    ,int            isBinary = 0
);

double cvGetCentralMoment(
     CvMoments* moments
    ,int        x_order
    ,int        y_order
);

double cvGetNormalizedCentralMoment(
     CvMoments* moments
    ,int        x_order
    ,int        y_order
);

void cvGetHuMoments(
     CvMoments*     moments
    ,CvHuMoments*   HuMoments
);
```

Первая функция аналогична *cvContoursMoments()* за исключением того, что принимает изображение (вместо контура) и один дополнительный аргумент. Этот дополнительный аргумент, если он установлен в *CV_TRUE*, говорит *cvMoments()* рассматривать все пиксели либо как 1, либо как 0, где 1 присваивается любому пикселю отличному от нуля. При вызове этой функции все моменты вычисляются сразу, в том числе и центральные (см. следующий параграф).

*Центральные моменты* вычисляются почти так же, как и пространственные, за исключением того, что значения *x* и *y* имеют смещение на значение их среднего:

![Формула 8-15 не найдена](Images/Frml_8_15.jpg)

где ![Формула 8-16 не найдена](Images/Frml_8_16.jpg) и ![Формула 8-17 не найдена](Images/Frml_8_17.jpg).

Нормированные моменты вычисляются почти так же, как и центральные, за исключением того, что необходимо еще разделить на соответствующую степень ![Формула 8-9 не найдена](Images/Frml_8_9.jpg) (под "соответствующей" подразумевается, что момент масштабируется за счет степени ![Формула 8-9 не найдена](Images/Frml_8_9.jpg) в результате чего нормированный момент не зависит от масштаба объекта):

![Формула 8-18 не найдена](Images/Frml_8_18.jpg)

И в завершении, *Hu инвариантные моменты* являются линейными комбинациями центральных моментов. Идея заключается в том, чтобы комбинируя различными нормированными центральными моментами можно было бы создать инвариантные функции, представляющие различные аспекты изображения таким образом, чтобы они были инварианты к масштабированию, вращению и отражению (для всех, кроме ![Формула 8-19 не найдена](Images/Frml_8_19.jpg))

Функция *cvGetHuMoments()* вычисляет *Hu* моменты на основе центральных моментов. Для полноты картины, ниже приведены фактические определения *Hu* моментов:

![Формула 8-20 не найдена](Images/Frml_8_20.jpg)

Глядя на рисунок 8-9 и таблицу 8-1 можно понять, как ведут себя *Hu* моменты. Не трудно заметить, что моменты уменьшаются по мере продвижения к более высоким порядкам. Это не должно вызывать удивления, т.к. по определению *Hu* моменты высших порядков имеют большее разнообразие нормированных коэффициентов. Т.к. каждый из этих коэффициентов меньше 1, их произведение и увеличение их количества дает в результате меньшее число.

![Рисунок 8-9 не найден](Images/Pic_8_9.jpg)

Рисунок 8-9. Изображение пяти простых символов; глядя на их Hu моменты можно интуитивно определить их поведение

Таблица 8-1. Значения Hu моментов для пяти простых символов показанных на рисунке 8-9

![Формула 8-23 не найдена](Images/Frml_8_23.jpg)

Коэффициенты, вызывающие интерес: символ "I" симметричен при вращении на 180 градусов и отображении и значения моментов равны 0 для ![Формула 8-21 не найдена](Images/Frml_8_21.jpg) - ![Формула 8-22 не найдена](Images/Frml_8_22.jpg); для символа "O", имеющего аналогичную симметрию, все моменты равны 0. 


### Сопоставление при помощи Hu моментов

```cpp
double cvMatchShapes(
     const void*    object1
    ,const void*    object2
    ,int            method
    ,double         parameter = 0
);
```

Потребность в сравнении двух объектов при помощи Hu моментов, так или иначе, может возникнуть. При этом есть множество определений "похожести". Чтобы сделать этот процесс несколько проще, в OpenCV есть функция *cvMatchShapes()*, которой необходимо просто передать два объекта и метод их сравнения.

Эти объекты могут быть серыми изображениями или контурами. Если будут переданы изображения, то функция сначала вычислит их моменты и только после это приступит к сравнению. Аргумент *method* может иметь одно из значений, перечисленных в таблицы 8-2.

Таблица 8-2. Методы сравнения, используемые в *cvMatchShapes()*

| Значение method | Возвращаемое значение |
| -- | -- |
| CV_CONTOURS_MATCH_I1 | ![Формула 8-24 не найдена](Images/Frml_8_24.jpg) |
| CV_CONTOURS_MATCH_I2 | ![Формула 8-25 не найдена](Images/Frml_8_25.jpg) |
| CV_CONTOURS_MATCH_I3 | ![Формула 8-26 не найдена](Images/Frml_8_26.jpg) |

В этой таблице ![Формула 8-27 не найдена](Images/Frml_8_27.jpg) и ![Формула 8-28 не найдена](Images/Frml_8_28.jpg) это:

![Формула 8-29 не найдена](Images/Frml_8_29.jpg)

![Формула 8-30 не найдена](Images/Frml_8_30.jpg)

где ![Формула 8-31 не найдена](Images/Frml_8_31.jpg) и ![Формула 8-32 не найдена](Images/Frml_8_32.jpg) это Hu моменты *A* и *B* соответственно.

Каждая из трех констант, перечисленная в таблице 8-2, имеет разное значение в плане того, как вычисляются метрики сравнения. В конечном счете, эта метрика определяет возвращаемое функцией значение. Последний аргумент *parameter* на момент написания книги не использовался, поэтому смело можно присвоить ему значение по умолчанию равное 0.


### Иерархическое сравнение

Довольно таки часто будет возникать необходимость сравнения двух контуров, а так же придумывание признаков подобия, которые бы принимали во внимание всю структуру сопоставляемых контуров. Методы, использующие сводную характеристику (такие как моменты) довольно таки быстры, однако они могут задействовать не так много информации.

Для более точного сравнения будет полезно сначала рассмотреть структуру известную как *дерево контура*. Дерево контура не следует путать с иерархическим представлением контура, возвращаемое такими функциями, как *cvFindContours()*. Вместо этого они являются иерархическим представлением формы какого-то одного контура.

Понять что такое дерево контура проще, если сначала понять, как оно устроено. Построение дерева контура начинается снизу (конечные узлы) и заканчивается сверху (корневой узел). Процесс начинается с поиска периметра треугольных выступов и углублений (точки контура не всегда коллинеарны со своими соседями). Каждый такой треугольник замещается линией, которая соединяет две не смежные точки на кривой, таким образом, треугольник либо отсекается (треугольник D, рисунок 8-10), либо заполняется (треугольник C). Каждое такое замещение удаляет одну вершину из контура и добавляет одну вершину в дерево. Если такой треугольник имеет две стороны, соответствующие оригинальной части контура, то это лист дерева; если одна из сторон данного треугольника является стороной существующего треугольника, то существующий треугольник является родителем для данного треугольника. Повторение данного процесса в конечном итоге сводит фигуру до четырехугольника, который в последующем разделяется пополам; получившиеся в результате треугольники являются потомками корневой вершины. 

![Рисунок 8-10 не найден](Images/Pic_8_10.jpg)

Рисунок 8-10. Построение дерева контура: в первом проходе вокруг автомобиля создаются конечные узлы A, B, C, и D; во втором проходе создаются X и Y (X является родителем для A и B, а Y является родителем для C и D)

Результирующее бинарное дерево (рисунок 8-11) в конечном счете, кодирует информацию о форме исходного контура. Каждый узел несет в себе информацию о треугольнике, с которым он связан (размер, а так же способ создания: отсечение или заполнение).

После того, как деревья построены, они могут быть использованы для эффективного сравнения двух контуров. 
Процесс сравнения начинается с попыток установки соответствия между узлами двух деревьев, а затем сравнения характеристик соответствующих узлов. Конечным результатом является степень сходства двух деревьев.

На практике не обязательно понимать все тонкости этого процесса. OpenCV предоставляет процедуры, позволяющие автоматически создавать деревья контуров из обычных *CvContour* объектов и конвертировать их обратно; так же имеется метод для сравнения двух деревьев. Но, к сожалению, данные деревья не очень надежные (так, незначительные изменения в контуре могут существенно изменить дерево). Кроме того, первоначальный треугольник (корень дерева) выбирается произвольно. В результате, чтобы получить лучшее представление, для начала необходимо применить функцию *cvApproxPoly()*, а затем выровнить контур (выполняя циклический сдвиг), чтобы начальный треугольник стал значительно менее зависимым от вращений.

```cpp
CvContourTree* cvCreateContourTree(
     const CvSeq*   contour
    ,CvMemStorage*  storage
    ,double         threshold
);

CvSeq* cvContourFromContourTree(
     const CvContourTree*   tree
    ,CvMemStorage*          storage
    ,CvTermCriteria         criteria
);

double cvMatchContourTrees(
     const CvContourTree*   tree1
    ,const CvContourTree*   tree2
    ,int                    method
    ,double                 threshold
);
```

![Рисунок 8-11 не найден](Images/Pic_8_11.jpg)

Рисунок 8-11. Бинарное представление двоичного дерева, которое может соответствовать контуру с рисунка 8-10

Этот код ссылается на структуру *CvTermCriteria*, о которой более подробно пойдет речь в главе 9. А пока достаточно будет знать, что эту структуру можно создать при помощи *cvTermCriteria()* с использованием следующих значений по умолчанию:

```cpp
CvTermCriteria termcrit = cvTermCriteria( CV_TERMCRIT_ITER | CV_TERMCRIT_EPS, 5, 1 );
```


### Выпуклость контура и дефекты выпуклости

Ещё один полезный способ, позволяющий понять, что такое форма объекта или контур это вычислить каркас выпуклости для объекта, а затем вычислить *дефект выпуклости*. Формы многих сложных объектов хорошо характеризуются такими дефектами.

Рисунок 8-12 иллюстрирует концепцию дефекта выпуклости, используя изображение человеческой руки. Каркас выпуклости изображен тёмной линией вокруг руки, а дефекты, относящиеся к этому каркасу, помечены буквами от A до H. Как можно было заметить, эти дефекты позволяют характеризовать не только саму руку, но так же и её состояние.

```cpp
#define CV_CLOCKWISE 1
#define CV_COUNTER_CLOCKWISE 2

CvSeq* cvConvexHull2(
     const CvArr*   input
    ,void*          hull_storage    = NULL
    ,int            orientation     = CV_CLOCKWISE
    ,int            return_points   = 0
);

int cvCheckContourConvexity(
     const CvArr*   contour
);

CvSeq* cvConvexityDefects(
     const CvArr*   contour
    ,const CvArr*   convexhull
    ,CvMemStorage*  storage = NULL
);
```

![Рисунок 8-12 не найден](Images/Pic_8_12.jpg)

Рисунок 8-12. Дефекты выпуклости: черная линия это каркас выпуклости вокруг руки; сетчатые регионы (A-H) это дефекты выпуклости контура руки по отношению к выпуклой оболочке

В OpenCV есть три наиболее важных метода, которые занимаются сложными каркасами и выпуклостями. Первый просто вычисляет каркас контура, а второй позволяет проверить является ли контур выпуклым. Третий метод вычисляет дефекты выпуклости в контуре, для которого уже известен каркас выпуклости.

Функция *cvConvexHull2()* в качестве первого аргумента принимает массив точек. Этот массив обычно является матрицей из двух столбцов и n строк (т.е. nx2) или контуром. Точки должны быть 32-битными целыми (*CV_32SC1*) или вещественными (*CV_32FC1*) числами. Следующий аргумент уже привычное хранилище памяти, в котором можно выделить место под результат. Следующий аргумент может быть либо *CV_CLOCKWISE*, либо *CV_COUNTER_CLOCKWISE*, определяющий ориентацию точек, которые будут возвращены функцией. Последний аргумент *returnPoints* может быть 0 или 1. Если установлен в 0, то в возвращаемом массиве будут сохранены только индексы (при этом, если аргумент имеет тип *CvSeq*\* или *CvContour*\*, то результатом будут указатели на точки), которые ссылаются на записи в массиве, переданный в *cvConvexHull2()*.

В этом месте внимательный читатель может спросить: "Если аргумент *hull_storage* это хранилище памяти, то почему он имеет тип *void*\*?". Это хороший вопрос. Так вот причина в том, что во многих случаях удобнее, если точки каркаса будут размещены в массиве, а не в последовательности. Принимая это во внимание, появляется возможность для передачи указателя на матрицу *CvMat*\* через аргумент *hull_storage*. В этом случае матрица должна быть одномерной и иметь столько же записей, сколько входных точек. На самом деле при вызове *cvConvexHull2()* заголовок матрицы будет меняться в соответствии с требуемым количеством столбцов. (Память, выделенная под данные матрицы, не перераспределяется в любом случае. Так как массивы являются C-массивами, то при удалении матриц память будет освобождаться верно).

Иногда даже при наличии контура, не известно является ли он выпуклым. В этом случае можно вызвать функцию *cvCheckContourConvexity()*. Тестирование данной функцией выполняется просто и быстро (на самом деле это занимает O(N) времени, что немного быстрее, чем O(N logN) времени, необходимого для построения каркаса выпуклости), однако будут некорректные результаты, если контур содержит самопересечения.

Третья функция *cvConvexityDefects()* вычисляет и возвращает последовательность дефектов. Функция запрашивает контур, каркас выпуклости и хранилище памяти для хранения результата. Первые два аргумента имеют тип *CvArr*\* и такую же форму, как аргумент *input* функции *cvConvexHull2()*.

```cpp
typedef struct CvConvexityDefect {
    // точка контура, где начинается дефект
    CvPoint* start;
    
    // точка контура, где заканчивается дефект
    CvPoint* end;
    
    // наиболее удалённая точка внутри дефекта от выпуклого каркаса
    CvPoint* depth_point;
    
    // расстояние между наиболее удалённой точкой и выпуклым каркасом
    float depth;
} CvConvexityDefect;
```

Функция *cvConvexityDefects()* возвращает последовательность структур *CvConvexityDefect*, содержащих несколько простых параметров, с помощью которых можно характеризовать дефект. Поля *start* и *end* - это точки на каркасе, где дефект начинается и заканчивается. Поле *depth_point* - это самая дальняя точка от края каркаса, в этой точке дефект начинает отклоняться. Поле *depth* - это расстояние между самой дальней точкой и краем каркаса.


### Попарные геометрические гистограммы

Ранее уже были кратко рассмотрены цепные коды Фримена. Как было тогда сказано цепные коды Фримена являются представлением многоугольника с точки зрения последовательности "ходов", где каждый ход имеет фиксированную длину и определенное направление. Однако не было рассказано о том, как можно было бы использовать такое представление.

Цепные коды Фримена находят свое применение при решении различного рода задач, но самое популярное применение стоит рассмотреть более подробно, потому что в основе идеи лежит использование *попарных геометрических гистограмм* (PGH - pairwise geometrical histogram) (в OpenCV реализован метод Iivarinen, Peura, Särelä и Visa).

PGH на самом деле являются обобщением или расширением, так называемых *цепных кодов гистограмм* (CCH - chain code histogram). CCH – это гистограмма, созданная путем подсчёта количества разновидностей кодов Фримена. Эта гистограмма обладает рядом хороших свойств. В частности, поворот объекта на 45 градусов циклически преобразует гистограмму (рисунок 8-13). Это обеспечивает независимость от вращений при распознавании объектов.

![Рисунок 8-13 не найден](Images/Pic_8_13.jpg)

Рисунок 8-13. Представление контура цепными кодами Фримена (сверху) и связных с ними цепными кодами гистограмм (снизу); когда исходный контур (a) повернут на 45 градусов по часовой стрелке (b), результаты цепных кодов гистограмм такие же, за исключением того факта, что во втором случае имеет место смещение на одну единицу вправо

Построение PGH происходит следующим образом (рисунок 8-14). Каждый из углов полигона последовательно выбирается в качестве "угла основания". Затем каждый из остальных краёв рассматривается относительно базового края, и вычисляются 3 значения: ![Формула 8-1 не найдена](Images/Frml_8_1.jpg), ![Формула 8-2 не найдена](Images/Frml_8_2.jpg) и ![Формула 8-33 не найдена](Images/Frml_8_33.jpg). ![Формула 8-1 не найдена](Images/Frml_8_1.jpg) – это наименьшее расстояние между двумя краями, ![Формула 8-2 не найдена](Images/Frml_8_2.jpg) – наибольшее, а ![Формула 8-33 не найдена](Images/Frml_8_33.jpg) – угол между ними. PGH - это двумерная гистограмма, размеры которой угол и расстояние. В частности, для каждого парного ребра имеется соответствующий контейнер (![Формула 8-1 не найдена](Images/Frml_8_1.jpg), ![Формула 8-33 не найдена](Images/Frml_8_33.jpg)) и соответствующий контейнер (![Формула 8-2 не найдена](Images/Frml_8_2.jpg), ![Формула 8-33 не найдена](Images/Frml_8_33.jpg)). Для каждой такой пары краёв, эти два контейнера увеличиваются – так же, как и все контейнеры на участке между ![Формула 8-1 не найдена](Images/Frml_8_1.jpg) и ![Формула 8-2 не найдена](Images/Frml_8_2.jpg).

![Рисунок 8-14 не найден](Images/Pic_8_14.jpg)

Рисунок 8-14. Парные геометрические гистограммы: каждые два края сегмента охватывающего многоугольника имеют угол, минимальное и максимальное расстояние (a); эти цифры кодируются в двумерную гистограмму (b), которая не зависит от вращений

И PGH и FCC полезны. Однако подход с использованием PGH обладает большей мощностью, поэтому он более полезен при решении сложных проблем, связанных с наличием большого количества форм, которые требуется распознать и/или которые обладают большой изменчивостью фонового шума. Функция для вычисления PGH выгладит следующим образом:

```cpp
void cvCalcPGH(
     const CvSeq*   contour
    ,CvHistogram*   hist
);
```

Аргумент *contour* содержит целочисленные координаты точек; аргумент *hist* может быть двумерным.

