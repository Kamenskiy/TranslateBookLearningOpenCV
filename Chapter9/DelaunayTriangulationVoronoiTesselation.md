## [П]|[РС]|(РП) Триангуляция Delaunay, тесселяция Voronoi

*Триангуляция Delaunay* - это техника, изобретенная в 1934 для соединения точек в пространстве в треугольную группу таким образом, чтобы минимальный угол среди всех углов в триангуляции был максимальным. Это означает, что триангуляция Delaunay пытается избегать "тонких" треугольников при триангуляции точек. Для того чтобы понять суть триангуляции посмотрите на рисунок 9-12: любая окружность, описанная вокруг вершин любого треугольника не содержит других вершин. Это именуется *свойством описанной окружности* (часть *c* на рисунке).

Чтобы вычисления были эффективными, алгоритм Delaunay начинает свою работу с самого далекого внешнего ограничивающего треугольника. На рисунке 9-12(b) фиктивный внешний треугольник представлен пунктирными линиями, сходящимся в вершине. На рисунке 9-12(c) представлено несколько примеров описанных окружностей, при этом одна из них связывает две реальные вершины и одну из вершин фиктивного внешнего треугольника.

![Рисунок 9-12 не найден](Images/Pic_9_12.jpg)

Рисунок 9-12. Триангуляция Delaunay: (a) множество точек; (b) Триангуляция Delaunay для набора точек, с пунктирными линиями внешнего ограничивающего треугольника; (c) пример описанных окружностей

На сегодняшний день существует множество алгоритмов для расчета триангуляции Delaunay; некоторые из них очень эффективные, но со сложными деталями реализации. Суть одного из наиболее простых алгоритмов в следующем:

1. Добавить внешний треугольник и начать с одной из его вершин (это гарантирует получение внешней отправной точки)
2. Добавить внутреннюю точку; затем "пройтись" по всем треугольникам с описанной окружностью содержащих эту точку и удалить эти триангуляции
3. Re-triangulate граф с включением новых точек в описанную окружность простым удалением триангуляций
4. Возвращаться к шагу 2 до тех пор, пока не останется точек для добавления

Сложность этого алгоритма составляет O(![Формула 9-8 не найдена](Images/Frml_9_8.jpg)). Наиболее эффективные алгоритмы (в среднем) имеют сложность O(n log log n).

Отлично – но для чего все это нужно? С одной стороны, нужно помнить, что этот алгоритм начинает свою работу с фиктивного внешнего треугольника, поэтому все настоящие внешние точки, на самом деле, соединены с двумя вершинами этого треугольника, а вот описанная окружность, проходящая через две реальные внешние точки и одну фиктивную внешнюю вершину, не содержит других внутренних вершин. Это означает, что компьютер сможет определить, какие реальные точки образуют внешний контур набора точек, просто просмотрев те точки, которые соединены с тремя внешними фиктивными вершинами. Другими словами, можно найти скелет набора точек сразу после того, как будет выполнена триангуляция Delaunay. 

Так же можно определить, кто "владеет" пространством между точками, а именно, чьи координаты являются ближайшими соседями до вершин Delaunay. Таким образом, используя триангуляцию Delaunay, можно найти ближайшего соседа для новой точки. Такое разбиение на плоскости называется *тесселяция Voronoi*. Тесселяция является двойным образом триангуляции Delaunay, потому что линии Delaunay определяют расстояние между существующими точками, а линии Voronoi "знают", где они должны пересекаться с линиями Delaunay для сохранения равного расстояния между точками. Эти два метода для нахождения выпуклой оболочки и ближайшего соседа, являются основными операциями кластеризации и классификации точек и наборов точек.

![Рисунок 9-13 не найден](Images/Pic_9_13.jpg)

Рисунок 9-13. Тесселяция Voronoi, в результате которой все точки в пределах данной ячейки Voronoi являются ближайшими к своим точкам Delaunay, чем к любым другим точкам Delaunay: (a) триангуляция Delaunay отмечена жирными линиями, а тесселяции Voronoi тонкими линиями, (b) ячейки Voronoi вокруг каждой точки Delaunay

Все те, кто знаком с 3D графикой могут отметить, что триангуляция Delaunay зачастую используется как основа для представления 3D фигур. Если имеется 3D представление объекта, то можно создать 2D представление этого объекта с помощью проекции, а затем использовать триангуляцию Delaunay для анализа и идентификации объекта и/или для сравнения его с реальным объектом. Триангуляция Delaunay это связующее звено между компьютерным зрением и компьютерной графикой. Однако, триангуляция Delaunay в OpenCV выполняется только для двумерного измерения (в дальнейшем планируется это исправить, глава 14). Если бы существовала возможность триангулировать множество 3D точек – скажем для стереозрения (глава 11) – то можно было бы плавно переходить между 3D графикой и компьютерным зрением. Тем не менее, 2D триангуляция Delaunay часто используется в компьютерном зрении для того, чтобы зарегистрировать пространственное расположение особенностей на объекте или сцене для отслеживания движений, распознавания объектов или для сравнения проекций с двух разных камер (при выводе глубины стереозрения). На рисунке 9-14 показано, как можно отслеживать и распознавать объекты при помощи триангуляции Delaunay, где ключевые точки лица пространственно классифицированы в соответствии с их триангуляцией.

![Рисунок 9-14 не найден](Images/Pic_9_14.jpg)

Рисунок 9-14. Точки Delaunay могут быть использованы для слежения за объектами; здесь лицо отслеживается с помощью точек, по которым можно также определить эмоции

Теперь, когда установлена потенциальная полезность триангуляции Delaunay, как собственно получить эту самую триангуляцию? Для решения этой задачи OpenCV поставляется вместе с примером *.../opencv/samples/c/delaunay.c*. В OpenCV триангуляцию Delaunay ссылается на понятие подраздел Delaunay, о чем собственно и пойдет речь в следующих разделах.


### Построение триангуляции Delaunay и тесселяции Voronoi

Для начала необходимо выделить место под хранение результатов триангуляции и тесселяции. Так же понадобиться внешний ограничивающий прямоугольник (чтобы ускорить вычисления, алгоритм должен работать с фиктивным внешним треугольником, который расположен за пределами ограничивающего прямоугольника). Для выполнения поставленной задачи, предположим, что точки располагаются внутри изображения 600x600:

```cpp
// Хранилище и структура для подраздела Delaunay
//
CvRect rect = { 0, 0, 600, 600 };   // Внешний ограничивающий прямоугольник

CvMemStorage* storage;              // Хранилище
storage = cvCreateMemStorage(0);    // Инициализация хранилища

CvSubdiv2D* subdiv;                 // Подраздел
subdiv = init_delaunay( storage, rect);
```

В коде используется функция *init_delaunay()*, которая является удобной "упаковкой" нескольких функций OpenCV:

```cpp
// Инициализация удобной функции для подраздела Delaunay
//
CvSubdiv2D* init_delaunay( CvMemStorage* storage, CvRect rect ) {
    CvSubdiv2D* subdiv;

    subdiv = cvCreateSubdiv2D(
         CV_SEQ_KIND_SUBDIV2D
        ,sizeof(*subdiv)
        ,sizeof(CvSubdiv2DPoint)
        ,sizeof(CvQuadEdge2D)
        ,storage
    );

    cvInitSubdivDelaunay2D( subdiv, rect ); // Установка ограничительного прямоугольника

    return subdiv;
}
```

Далее представлена логика добавления точек. Эти точки должны быть типа float, 32F:

```cpp
CvPoint2D32f fp; // Собственно сами точки
for( i = 0; i < as_many_points_as_you_want; i++ ) {
    // Собственно само добавление
    // 
    fp = your_32f_point_list[i];
    cvSubdivDelaunay2DInsert( subdiv, fp );
}
```

Можно конвертировать целые точки в 32f точки с помощью удобного макроса *cvPoint2D32f(double x, double y)* или *cvPointTo32f(CvPoint point)*, расположенного в *cxtypes.h*. Теперь, когда можно добавлять точки в триангуляцию Делоне, появляется возможность создавать и удалять соответствующую тесселяцию Вороного:

```cpp
cvCalcSubdivVoronoi2D( subdiv ); // Занести данные Voronoi в subdiv
cvClearSubdivVoronoi2D( subdiv ); // Удалить данные Voronoi из subdiv
```

В обеих функциях *subdiv* имеет тип *CvSubdiv2D*\*. Теперь можно создавать триангуляции Delaunay из 2-х мерных наборов точек с последующим созданием и удалением тесселяций Voronoi. Однако, как получить нужные данные из этих структур? Это можно сделать, шагая от ребра к вершине или от ребра к ребру в *subdiv*; на рисунке 9-15 показаны основные манёвры, начиная с заданного ребра и его точки отсчета. Далее можно найти первые ребра или вершины двумя разными способами: (1) используя внешнюю точку для обнаружения ребра или вершин; или (2) шагая по последовательности вершин или рёбер. 


### Перемещение по подразделам Delaunay

Рисунок 9-15 сочетает в себе две структуры данных, которые будут использованы для перемещения по подразделам графа. 

Структура *cvQuadEdge2D* содержит набор из двух точек *Delaunay* и двух точек *Voronoi*, и связанные с ними рёбра (предполагается, что точки *Voronoi* и рёбра были рассчитаны с помощью *cvCalcSubdivVoronoi2D()*); рисунок 9-16. Структура *CvSubdiv2DPoint* содержит ребро *Delaunay* с сопутствующей вершиной, как показано на рисунке 9-17. Структура из четырёх рёбер определена в соответствии с рисунком.

![Рисунок 9-15 не найден](Images/Pic_9_15.jpg)

Рисунок 9-15. Ребра относительно заданного ребра, с меткой "e", и его вершина (отмечена квадратом)

![Рисунок 9-16 не найден](Images/Pic_9_16.jpg)

Рисунок 9-16. Quad edges, к которым можно получить доступ при помощи cvSubdiv2DRotateEdge(), включая ребро Delaunay и противоположное ему ребро, а также соответствующие рёбра и вершины Voronoi

![Рисунок 9-17 не найден](Images/Pic_9_17.jpg)

Рисунок 9-17. CvSubdiv2DPoint вершина и связанное с ней ребро e, вместе с другими связанными рёбрами, которые могут быть получены с помощью cvSubdiv2DGetEdge()

```cpp
// Рёбра представляют собой длинные целые числа. Младшие два бита
// это их индекс (0..3), а старшие - указатель quad-edge
// 
typedef long CvSubdiv2DEdge;

// Поля структуры quad-edge
// 
#define CV_QUADEDGE2D_FIELDS()      /
    int flags;                      /
    struct CvSubdiv2DPoint* pt[4];  /
    CvSubdiv2DEdge next[4];
 
typedef struct CvQuadEdge2D {
    CV_QUADEDGE2D_FIELDS()
} CvQuadEdge2D;
```

Точки подраздела Delaulay и соответствующая структура ребра определяется следующим образом:

```cpp
#define CV_SUBDIV2D_POINT_FIELDS()  /
    int flags;                      /
    CvSubdiv2DEdge first;           /   /* Ребро "e" на рисунке */
    CvPoint2D32f pt;
 
#define CV_SUBDIV2D_VIRTUAL_POINT_FLAG (1 << 30)
 
typedef struct CvSubdiv2DPoint {
    CV_SUBDIV2D_POINT_FIELDS()
} CvSubdiv2DPoint;
```

С помощью этих структур, можно рассмотреть различные способы перемещения по вершинам и рёбрам.

**Обход рёбер**

Как показано на рисунке 9-16, перемещаться между четырьмя ребрами можно при помощи следующей функции:

```cpp
CvSubdiv2DEdge cvSubdiv2DRotateEdge(
     CvSubdiv2DEdge edge
    ,int type
);
```

При наличии *edge* (ребра) получить следующее ребро можно используя аргумент *type*, который принимает одно из следующих значений:

* 0, исходное ребро (*e* на фигуре, если *e* исходное ребро)

* 1, поворотное ребро (*eRot*)

* 2, противоположное ребро (противоположное *e*)

* 3, противоположное поворотному ребру (противоположное *eRot*)

Ссылаясь на рисунок 9-17, так же возможно обойти граф Delaunay при помощи следующей функции:

```cpp
CvSubdiv2DEdge cvSubdiv2DGetEdge(
     CvSubdiv2DEdge edge
    ,CvNextEdgeType type
);
 
#define cvSubdiv2DNextEdge( edge )  /
    cvSubdiv2DGetEdge(              /
         edge                       /
        ,CV_NEXT_AROUND_ORG         /
    )
```

Аргумент *type* может принимать следующие значения:

*CV_NEXT_AROUND_ORG*

Следующее от исходного ребро (*eOnext* на рисунке 9-17, если *e* исходное ребро)

*CV_NEXT_AROUND_DST*

Ребро следующей вершины (*eDnext*)

*CV_PREV_AROUND_ORG*

Предыдущее от исходного ребро (противоположное *eRnext*)

*CV_PREV_AROUND_DST*

Предыдущее от ребра назначения (противоположное *eLnext*)

*CV_NEXT_AROUND_LEFT*

Следующее от левой грани (*eLnext*)

*CV_NEXT_AROUND_RIGHT*

Следующее от правой грани (*eRnext*)

*CV_PREV_AROUND_LEFT*

Предыдущее от левой грани (противоположное *eOnext*)

*CV_PREV_AROUND_RIGHT*

Предыдущее от правой грани (противоположное *eDnext*)

Стоит отметить, что указанное ребро, связанное с вершиной, можно задействовать при использовании макроса *cvSubdiv2DNextEdge( edge )*, чтобы найти все остальные ребра этой вершины. Это полезно использовать в случае с выпуклой оболочкой, начинающейся из вершины внешнего (фиктивного) треугольника.

Важными видами обхода являются *CV_NEXT_AROUND_LEFT* и *CV_NEXT_AROUND_RIGHT*. Их можно использовать для обхода треугольника Delaunay, если находиться на ребре Delaunay или для обхода ячеек Voronoi, если находиться на ребре Voronoi.

**Точки ребер**

Помимо всего прочего, необходимо знать, как получать фактические точки из вершин Delaunay или Voronoi. Каждое ребро Delaunay или Voronoi имеет две точки, связанные с ним: *org* - исходная точка и *dst* - конечная точка. Эти точки легко можно получить при помощи следующих функций:

```cpp
CvSubdiv2DPoint* cvSubdiv2DEdgeOrg( CvSubdiv2DEdge edge );
CvSubdiv2DPoint* cvSubdiv2DEdgeDst( CvSubdiv2DEdge edge );
```

Следующий метод можно использовать для преобразования *CvSubdiv2DPoint* в более привычный вид:

```cpp
CvSubdiv2DPoint ptSub;                              // Вершина для преобразования
CvPoint2D32f    pt32f   = ptSub->pt;                // преобразование к типу 32f
CvPoint         pt      = cvPointFrom32f(pt32f);    // преобразование к целочисленному типу
```

На данный момент должно было сформироваться представление о структуре подраздела и о том, как совершать обход его вершин и ребер. Теперь можно вернуться к рассмотрению методов получения исходных ребер и вершин подразделов Delaunay/Voronoi.

**Метод 1: использование внешних точек для нахождения ребер и вершин**

Первый метод начинает свою работу с произвольной точки и поиска её местоположения в данном подразделе. Это необязательно должна быть точка, которая уже триангулирована; это может быть любая точка. Функция *cvSubdiv2DLocate()* занимает одно ребро и одну вершину (если необходимо) треугольника или грани Voronoi, в который эта точка упала. 

```cpp
CvSubdiv2DPointLocation cvSubdiv2DLocate(
     CvSubdiv2D*        subdiv
    ,CvPoint2D32f       pt
    ,CvSubdiv2DEdge*    edge
    ,CvSubdiv2DPoint**  vertex = NULL
);
```

Стоит обратить внимание на тот факт, что это не обязательно должны быть ближайшие *edge* (ребро) или *vertex* (вершина); достаточно будет и того, чтобы они были на треугольнике или гране. Возвращаемое значение данной функции сообщает о состоянии попадания точки.

*CV_PTLOC_INSIDE*

Точка попадает на некую грань; \**edge* будет содержать одно из ребер грани

*CV_PTLOC_ON_EDGE*

Точка попадает на ребро; \**edge* будет содержать это ребро

*CV_PTLOC_VERTEX*

Точка совпадает с одной из вершин подраздела; \**vertex* будет содержать указатель на вершину

*CV_PTLOC_OUTSIDE_RECT*

Точка находится за пределами прямоугольника; функция вернет не заполненный указатель

*CV_PTLOC_ERROR*

Один из исходных аргументов является недействительным

**Метод 2: последовательный обход точек и ребер**

Удобен при использовании подраздела Delaunay, созданного из множества точек; его первые три точки и ребра образуют вершины и стороны фиктивного внешнего ограничивающего треугольника. Как результат, получение доступа к внешним точкам и ребрам, которые формируют выпуклую оболочку из фактических точек данных. После создания подраздела Delaunay (*subdiv*), необходимо вызвать *cvCalcSubdivVoronoi2D( subdiv )* для того, чтобы рассчитать связанную с ним тесселяцию Voronoi. Получить доступ к трем вершинам внешнего ограничивающего треугольника можно следующим образом:

```cpp
CvSubdiv2DPoint* outer_vtx[3];

for( i = 0; i < 3; i++ ) {
    outer_vtx[i] = (CvSubdiv2DPoint*)cvGetSeqElem( (CvSeq*)subdiv, I );
}
```

Аналогичным образом можно получить три стороны внешнего ограничительного треугольника:

```cpp
CvQuadEdge2D* outer_qedges[3];

for( i = 0; i < 3; i++ ) {
    outer_qedges[i] = (CvQuadEdge2D*)cvGetSeqElem( (CvSeq*)(my_subdiv->edges), I );
}
```

Теперь, зная, как построить граф и как по нему перемещаться, необходимо научиться определять местоположение точек – на внешнем краю или границе?

**Определение ограничивающего треугольника, или краев выпуклой оболочки и её обход**

Ограничивающий прямоугольник *rect* используется для инициализации триангуляции Delaunay при помощи функции *cvInitSubdivDelaunay2D( subdiv, rect )*. В таком случае, справедливы следующие утверждения:

1. Если имеется ребро, у которого и исходная и конечная точки находятся вне границ *rect* (прямоугольника), тогда ребро принадлежит фиктивному ограничивающему треугольнику подраздела.

2. Если одна из точек ребра находится внутри, а другая за пределами границ *rect* (прямоугольника), то точка границы находится в выпуклой оболочке множества; каждая точка выпуклой оболочки связана с двумя вершинами фиктивного внешнего ограничивающего треугольника и эти два ребра следуют друг за другом.

Для второго условия можно использовать *cvSubdiv2DNextEdge()*, чтобы перейти на первое ребро, у которого точка *dst* находится в пределах границ. После попадания на выпуклую оболочку, по ней можно перемещаться следующим образом:

1. Пока не произошел обход всей выпуклой оболочки, перейти к следующему ребру оболочки при помощи *cvSubdiv2DRotateEdge(CvSubdiv2DEdge edge, 0)*.

2. Последующие вызовы (дважды) *cvSubdiv2DNextEdge()* дают следующие ребра выпуклой оболочки. Вернуться к шагу 1.

На данный момент было рассмотрено, как инициализировать подразделы Delaunay и Voronoi, как искать исходные ребра, а также как совершать обход ребер и вершин графа. В следующем разделе будут представлены примеры реализации рассмотренного материала.


### Примеры использования

Можно использовать *cvSubdiv2DLocate()* для обхода ребер треугольника Delaunay:

```cpp
void locate_point(
     CvSubdiv2D*    subdiv
    ,CvPoint2D32f   fp
    ,IplImage*      img
    ,CvScalar       active_color
) {
    CvSubdiv2DEdge      e;
    CvSubdiv2DEdge      e0  = 0;
    CvSubdiv2DPoint*    p   = 0;

    cvSubdiv2DLocate( subdiv, fp, &e0, &p );

    if( e0 ) {
        e = e0;

        // Всегда 3 ребра – это ведь триангуляция
        //
        do {
            // [Вставте свой код сюда]
            //
            
            // Сделать что-то с e …
            // 
            e = cvSubdiv2DGetEdge(e,CV_NEXT_AROUND_LEFT);
        }
        while( e != e0 );
    }
}
```

Найти ближайшие точки исходной точки можно при помощи

```cpp
CvSubdiv2DPoint* cvFindNearestPoint2D(
     CvSubdiv2D*    subdiv
    ,CvPoint2D32f   pt
);
```

В отличие от *cvSubdiv2DLocate()*, *cvFindNearestPoint2D()* возвращает ближайшую точку вершины в подразделе Delaunay. Не гарантировано, что точка обязательно попадет на грань или треугольник.

Аналогичным образом можно обойти грань Voronoi при помощи

```cpp
void draw_subdiv_facet(
     IplImage       *img
    ,CvSubdiv2DEdge edge
) {
    CvSubdiv2DEdge t = edge;
    int i, count = 0;
    CvPoint* buf = 0;

    // Подсчет количества ребер на грани
    // 
    do{
        count++;
        t = cvSubdiv2DGetEdge( t, CV_NEXT_AROUND_LEFT );
    } while (t != edge );

    // Сбор точек
    // 
    buf = (CvPoint*)malloc( count * sizeof(buf[0]));
    t = edge;
    for( i = 0; i < count; i++ ) {
        CvSubdiv2DPoint* pt = cvSubdiv2DEdgeOrg( t );
        if( !pt ) {
            break;
        }
        buf[i] = cvPoint( cvRound(pt->pt.x), cvRound(pt->pt.y) );
        t = cvSubdiv2DGetEdge( t, CV_NEXT_AROUND_LEFT );
    }

    // Обход
    //
    if( i == count ){
        CvSubdiv2DPoint* pt = cvSubdiv2DEdgeDst(
	         cvSubdiv2DRotateEdge( edge, 1 )
        );

        cvFillConvexPoly( 
             img
            ,buf 
            ,count
            ,CV_RGB(rand()&255,rand()&255,rand()&255)
            ,CV_AA
            ,0
        );

        cvPolyLine(
             img
            ,&buf
            ,&count
            ,1
            ,1
            ,CV_RGB(0,0,0)
            ,1
            ,CV_AA
            ,0
        );

        draw_subdiv_point( img, pt->pt, CV_RGB(0,0,0) );
    }

    free( buf );
}
```

И в заключении, есть ещё один способ получения доступа к подразделу, используя *CvSeqReader* для перебора последовательности ребер. Перебор всех ребер Delaunay и Voronoi можно осуществить следующим образом:

```cpp
void visit_edges( CvSubdiv2D* subdiv) {
    CvSeqReader reader;                         // Последовательность reader
    int i, total = subdiv->edges->total;        // Количество ребер
    int elem_size = subdiv->edges->elem_size;   // Размер ребра

    cvStartReadSeq( (CvSeq*)(subdiv->edges), &reader, 0 );
    cvCalcSubdivVoronoi2D( subdiv ); // Проверка существования

    for( i = 0; i < total; i++ ) {
        CvQuadEdge2D* edge = (CvQuadEdge2D*)(reader.ptr);

        if( CV_IS_SET_ELEM( edge )) {
            // Что-то сделать с ребрами Delaunay и Voronoi
            //
            CvSubdiv2DEdge voronoi_edge = (CvSubdiv2DEdge)edge + 1;
            CvSubdiv2DEdge delaunay_edge = (CvSubdiv2DEdge)edge;

            // … или сосредоточиться только на Voronoi

            // левое
            //
            voronoi_edge = cvSubdiv2DRotateEdge( edge, 1 );

            // правое
            //
            voronoi_edge = cvSubdiv2DRotateEdge( edge, 3 );
        }
        CV_NEXT_SEQ_ELEM( elem_size, reader );
    }
}
```

И в заключении: выполнив поиск трех вершин, можно найти площадь треугольника

```cpp
double cvTriangleArea(
     CvPoint2D32f   a
    ,CvPoint2D32f   b
    ,CvPoint2D32f   c
)
```
