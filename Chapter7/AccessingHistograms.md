## [П]|[РС]|(РП) Доступ к Histogram

Есть несколько способов получить доступ к данным гистограмм. Наиболее простой: использовать функции OpenCV:

```cpp
    double cvQueryHistValue_1D(
         CvHistogram*   hist
        ,int            idx0
    );

    double cvQueryHistValue_2D(
         CvHistogram*   hist
        ,int            idx0
        ,int            idx1
    );

    double cvQueryHistValue_3D(
         CvHistogram*   hist
        ,int            idx0
        ,int            idx1
        ,int            idx2
    );

    double cvQueryHistValue_nD(
         CvHistogram*   hist
        ,int*           idxN
    );
```

Каждая из этих функций возвращает вещественное значение для соответствующего контейнера. Кроме того, при помощи этих функций можно установить (или получить) значение контейнера за счет указателя на него (а не самого объекта):

```cpp
    float* cvGetHistValue_1D(
         CvHistogram*   hist
        ,int            idx0
    );

    float* cvGetHistValue_2D(
         CvHistogram*   hist
        ,int            idx0
        ,int            idx1
    );

    float* cvGetHistValue_3D(
         CvHistogram*   hist
        ,int            idx0
        ,int            idx1
        ,int            idx2
    );

    float* cvGetHistValue_nD(
         CvHistogram*   hist
        ,int*           idxN
    );
```

Эти функции похожи на семейство функций **cvGetReal**\***D** и **cvPtr**\***D** и фактически они делают почти тоже самое. По сути эти функции работают с теми же матрицами, которые они получают при помощи *hist->bins*. Кроме того, функции, работающие с разряжёнными гистограммами, наследуют поведение соответствующих функций для работы с разряжёнными матрицами. При попытке обращения к несуществующему контейнеру при помощи функции **GetHist**\***()** в разряженной гистограмме, контейнер будет создан автоматически и его значение будет установлено в 0. В свою очередь, функции QueryHist\*() не создают недостающих контейнеров.

Во многих случаях, при работе с *плотными гистограммами* необходимо получать прямой доступа к контейнерам. Конечно, можно было бы сделать это при помощи прямого доступа к данным гистограмм. Например, можно получить прямой доступ ко всем элементам плотной гистограммы последовательно или непосредственно к контейнерам гистограммы для увеличения производительности; в этом случае можно воспользоваться *hist->mat.data.fl* (только для плотных гистограмм). Причин, по которым можно использовать представленные далее примеры, много, одни из возможных - это поиск размерности гистограммы, определение какие регионы представляют отдельные контейнеры и т.п. Для получения этой информации можно использовать следующие приемы (получение доступа либо к фактическим данным в структуре *CvHistogram*, либо к информации, вложенной в структуру *CvMatND* известной как *mat*):

```cpp
int n_dimension = histogram->mat.dims;
int dim_i_nbins = histogram->mat.dim[ i ].size;
 
// для плотных гистограмм
int dim_i_bin_lower_bound = histogram->thresh[ i ][ 0 ];
int dim_i_bin_upper_bound = histogram->thresh[ i ][ 1 ];
 
// для разряжённых гистограмм
int dim_i_bin_j_lower_bound = histogram->thresh2[ i ][ j ];
int dim_j_bin_j_upper_bound = histogram->thresh2[ i ][ j+1 ];
```

Как можно было бы заметить, много чего происходит внутри структуры *Histogram*.

